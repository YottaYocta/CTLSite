---
interface Props {
  objData?: string;
  class?: string;
}

const { objData = "", class: className } = Astro.props;
---

<div
  class:list={["obj-viewer-container relative", className]}
  data-obj={objData}
>
  <canvas
    class="obj-viewer w-full h-full [image-rendering:pixelated] cursor-grab active:cursor-grabbing"
  ></canvas>
</div>

<script>
  import * as THREE from "three";
  import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
  import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
  import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
  import checkerFrag from "../shaders/checker.frag?raw";
  import { createHeatmapGradientCanvas } from "../utils/heatmapGradient";
  import { OrbitControls } from "three/examples/jsm/Addons.js";

  const initObjViewer = (container: HTMLElement) => {
    const canvas = container.querySelector(".obj-viewer") as HTMLCanvasElement;
    const objData = container.dataset.obj ?? "";

    const width = container.offsetWidth;
    const height = container.offsetHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const frustumSize = 5;
    const aspect = width / height;
    const camera = new THREE.OrthographicCamera(
      (frustumSize * aspect) / -2,
      (frustumSize * aspect) / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      1000,
    );
    camera.position.z = 5;
    camera.position.y = -1;
    camera.lookAt(0, 0.1, 0);

    const controls = new OrbitControls(camera, canvas);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1;
    controls.enableDamping = true;
    controls.minPolarAngle = Math.PI * (1 / 2 - 1 / 8);
    controls.maxPolarAngle = Math.PI * (1 / 2 + 1 / 16);
    controls.enablePan = false;
    controls.enableZoom = false;

    controls.update();

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(-5, -3, 4);
    scene.add(directionalLight);

    let object: THREE.Object3D;

    if (objData && objData.trim() !== "") {
      const loader = new OBJLoader();
      object = loader.parse(objData);

      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 3.5 / maxDim;

      object.position.sub(center);
      object.scale.setScalar(scale);
    } else {
      const geometry = new THREE.SphereGeometry(1, 10, 5);
      const material = new THREE.MeshStandardMaterial({
        color: 0x888888,
        flatShading: true,
      });
      object = new THREE.Mesh(geometry, material);
    }

    scene.add(object);

    const bayerData = new Uint8Array([
      0, 128, 32, 160, 8, 136, 40, 168, 192, 64, 224, 96, 200, 72, 232, 104, 48,
      176, 16, 144, 56, 184, 24, 152, 240, 112, 208, 80, 248, 120, 216, 88, 12,
      140, 44, 172, 4, 132, 36, 164, 204, 76, 236, 108, 196, 68, 228, 100, 60,
      188, 28, 156, 52, 180, 20, 148, 252, 124, 220, 92, 244, 116, 212, 84,
    ]);

    const bayerTexture = new THREE.DataTexture(
      bayerData,
      8,
      8,
      THREE.RedFormat,
      THREE.UnsignedByteType,
    );
    bayerTexture.wrapS = THREE.RepeatWrapping;
    bayerTexture.wrapT = THREE.RepeatWrapping;
    bayerTexture.minFilter = THREE.NearestFilter;
    bayerTexture.magFilter = THREE.NearestFilter;
    bayerTexture.needsUpdate = true;

    const heatmapGradientCanvas = createHeatmapGradientCanvas();
    const gradientTexture = new THREE.CanvasTexture(heatmapGradientCanvas);
    gradientTexture.minFilter = THREE.LinearFilter;
    gradientTexture.magFilter = THREE.LinearFilter;
    gradientTexture.wrapS = THREE.ClampToEdgeWrapping;

    const composer = new EffectComposer(renderer);

    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const ditherShader = {
      uniforms: {
        tDiffuse: { value: null },
        tBayer: { value: bayerTexture },
        tGradient: { value: gradientTexture },
        uTime: { value: 0 },
        uResolution: { value: new THREE.Vector2(width, height) },
        uDitherSize: { value: 2 },
        uNumColors: { value: 2 },
        uIntensity: { value: 0.3 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: checkerFrag.replaceAll("tSource", "tDiffuse"),
    };

    const ditherPass = new ShaderPass(ditherShader);
    composer.addPass(ditherPass);

    let time = 0;
    const randomRotationOffset = Math.random();
    const animate = () => {
      requestAnimationFrame(animate);
      time += 0.01;

      controls.update();

      // object.rotation.y =
      //   Math.sin(time * 0.1 + (randomRotationOffset * Math.PI) / 8) * 0.5;

      ditherPass.uniforms.uTime.value = time;
      ditherPass.uniforms.tBayer.value = bayerTexture;

      composer.render();
    };

    animate();

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        const newAspect = width / height;
        camera.left = (frustumSize * newAspect) / -2;
        camera.right = (frustumSize * newAspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = frustumSize / -2;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
        ditherPass.uniforms.uResolution.value.set(width, height);
      }
    });

    resizeObserver.observe(container);
  };

  document
    .querySelectorAll<HTMLElement>(".obj-viewer-container")
    .forEach((container) => {
      initObjViewer(container);
    });
</script>
